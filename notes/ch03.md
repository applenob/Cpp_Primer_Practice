# 第三章 字符串、向量和数组

## using声明

- 标准库中的各类对象基本都属于`std`命名空间，用到时必须通过作用域运算符`::`来访问。
- 通过预先进行`using`声明，可简化命名空间内成员的访问。
  - 如`using std::cin;`表示使用命名空间`std`中的名字`cin`，有了这条声明，后面就可以直接写`cin`。
- 每个名字都需要独立的`using`声明。
- 头文件中不应该包含`using`声明，不然容易产生冲突。

## string

- 定义在`<string>`中，表示可变长的字符序列。
- 注意`string`对象不同于字符串字面值。

### 定义和初始化

- 初始化`string`对象的方式有：

  | 方式 | 解释 |
  | -- | -- |
  | `string s1` | 默认初始化，`s1`是个空字符串 |
  | `string s2(s1)` | `s2`是`s1`的副本 |
  | `string s2 = s1` | 等价于`s2(s1)` |
  | `string s3("value")` | `s3`是字面值`“value”`的副本，除了字面值最后的那个空字符外 |
  | `string s3 = "value"` | 等价于`s3("value")` |
  | `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

  - 使用等号`=`将一个已有的对象拷贝到正在创建的对象的过程为**拷贝初始化**（copy initialization）。
  - 通过括号给对象赋值则为**直接初始化**（direct initialization）。

### string对象上的操作

- `string`支持的操作有：

  | 操作 | 解释 |
  |-----|-----|
  | `os << s` | 将`s`写到输出流`os`当中，返回`os` |
  | `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
  | `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
  | `s.empty()` | `s`为空返回`true`，否则返回`false` |
  | `s.size()` | 返回`s`中字符的个数，类型为`string::size_type` |
  | `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从`0`计起 |
  | `s1+s2` | 返回`s1`和`s2`连接后的结果 |
  | `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
  | `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等，对字母的大小写敏感 |
  | `s1!=s2` | 同上 |
  | `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，对字母的大小写敏感 |

  - 用输入运算符`>>`执行读操作时，将忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
  - `getline`则将读取包括空白符在内的一整行。
  - `string::size_type`为足够存在任何`string`对象大小的无符号类型。

### 处理string对象中的字符

- `<cctype>`中定义了一组标准函数：

  | 函数 | 解释 |
  |-----|-----|
  | `isalnum(c)` | 当`c`是字母或数字时为真 |
  | `isalpha(c)` | 当`c`是字母时为真 |
  | `iscntrl(c)` | 当`c`是控制字符时为真 |
  | `isdigit(c)` | 当`c`是数字时为真 |
  | `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
  | `islower(c)` | 当`c`是小写字母时为真 |
  | `isprint(c)` | 当`c`是可打印字符时为真 |
  | `ispunct(c)` | 当`c`是标点符号时为真 |
  | `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
  | `isupper(c)` | 当`c`是大写字母时为真 |
  | `isxdigit(c)` | 当`c`是十六进制数字时为真 |
  | `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
  | `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

- 可用**范围for**（range for）语句来遍历`string`中的字符：`for (auto c: str)`，其中`c`的类型将被推断为`char`。
  - 使用引用直接改变字符串中的字符：`for (auto &c: str)`。

## vector

- `<vector>`中定义的标准库类型`vector`是可包含其他对象一种**容器**（container），它是一个类模板。
- 类模板本身不是类，需要通过传入的模板实参，**实例化**（instantiation）出一个类。
  - 模板实参一般放在类模板名称后面的**尖括号**中，如`vector<int> ivec`声明了一个保存`int`类型的`vector`对象。

### 定义和初始化vector对象

- 初始化`vector`对象的方法有：

  | 方法 | 解释 |
  |-----|-----|
  | `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
  | `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
  | `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
  | `vector<T> v3(n, val)` | `v3`包含了`n`个重复的元素，每个元素的值都是`val` |
  | `vector<T> v4(n)` | `v4`包含了`n`个重复地执行了值初始化的对象 |
  | `vector<T> v5{a, b, c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
  | `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

  - C++11支持对`vector`进行列表初始化，如`vector<string> v{"a", "an", "the"};`。
  - 用花括号的形式进行初始化时，如果提供的值不能用来列表初始化，编译器将尝试进行默认初始化。
  
### vector操作

- `vector`支持的操作有：

  | 操作 | 解释 |
  |-----|-----|
  | `v.emtpy()` | 如果`v`不含有任何元素，返回真，否则返回假 |
  | `v.size()` |  返回`v`中元素的个数，类型为`vector<T>::size_type` |
  | `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
  | `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
  | `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
  | `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
  | `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
  | `v1 != v2` | 同上 |
  | `<`,`<=`,`>`,`>=` | 以字典顺序进行比较 |

  - 范围`for`语句内不应该改变其遍历序列的大小。
  - `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

## 迭代器

- 所有标准库容器都可以使用**迭代器**（iterator）。
- 类似于指针类型，迭代器也提供了对对象的间接访问。
- 有效的迭代器或指向某个元素，或指向容器中尾元素的下一位置。

### 使用迭代器

- 支持迭代器的类型都定义了名为`begin`和`end`的成员：
  - `v.begin()`：返回指向第一个元素的迭代器。
  - `v.end()`：返回指向尾元素下一位置的迭代器，称为**尾后迭代器**（off-the-end iterator）。
  - 容器为空时，`begin`和 `end`都将返回尾后迭代器。
- 标准容器迭代器都支持的运算有:

  | 运算符 | 解释 |
  |-----|-----|
  | `*iter` | 返回迭代器`iter`所指向的元素的**引用** |
  | `iter->mem` | 等价于`(*iter).mem` |
  | `++iter` | 令`iter`指示容器中的下一个元素 |
  | `--iter` | 令`iter`指示容器中的上一个元素 |
  | `iter1 == iter2`<br>`iter1 != iter2`| 判断两个迭代器是否相等 |

  - 大多数迭代器都没有定义大小比较运算符，因此迭代器间的判断应该用`==`或`!=`来完成。
  - `(*iter).mem`中结合了解引用和成员访问操作，其中的括号不可少，而箭头运算符`->`把两个操作结合到了一起。
- 标准库中使用`iterator`和`const_iterator`来表示迭代器类型，后者为只读迭代器。
  - 例如`string::iterator it;`，`it`可读写`string`对象的字符；
  - `vector<int>::const_iterator cit;`，`cit`只能读取`vector<int>`中的元素。
- `begin`和`end`成员返回的迭代器类型由对象本身是否为常量决定。
  - C++11中定义了`cbegin`和`cend`，可用来直接得到常量类型的迭代器。
- 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，否则将导致迭代器失效。

### 迭代器运算

- `vector`和`string`都支持的迭代器运算有：

  | 运算符 | 解释 |
  |-----|-----|
  | `iter + n`<br>`iter - n` | 迭代器加上（减去）一个整数值仍得到一个迭代器，迭代器指示的新位置或和原来相比向前（向后）移动了若干个元素，或为尾后迭代器 |
  | `iter1 += n`<br>`iter1 -= n` | 迭代器复合赋值语句，将`iter1`加（减）`n`的结果赋给`iter1` |
  | `iter1 - iter2` | 两个迭代器之间的距离，类型`difference_type`为带符号的整型，参与运算的两个迭代器必须指向同一个容器 |
  | `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，相互比较的迭代器必须指向同一个容器。如果某迭代器指向的容器位置在另一个之前，则前者小于后者 |

## 数组

- 继承自C，相当于`vector`的低级版，长度固定。

### 定义和初始化内置数组

- 初始化时：
  - 必须指定类型，不允许用`auto`由初始值的列表推断类型。
  - 长度必须是**常量表达式**，或者进行列表初始化，而由编译器自行推断。
- 数组的内容不可拷贝给其他数组作为其初始值，也不可用数组为其他数组赋值。
- 注意正确理解复杂的数组声明：
  - `int *ptrs[10];`：含有10个整型指针的数组`ptrs`；
  - `int (*Parray)[10] = &arr;`：`Parray`指向一个含有`10`个整数的数组；
  - `int (&arrRef)[10] = arr;`：`arrRef`是一个含有`10`个整数的数组的引用。

### 访问数组元素

- 数组下标是定义在`<cstddef>`的`size_t`类型，它是机器相关的无符号类型。
- 注意字符数组的特殊性：其结尾处有一个空字符`\0`，如 `char a[] = "hello";` 。

### 指针和数组

- 在很多用到数组名字的地方，编译器会自动把它转换成指向数组首元素的指针。
  - 如`int ia[10]; auto ia2(ia); decltype(ia) ia3;`中，`ia2`将推断为`int *`类型, `ia3`则为`int[10]`类型。
- 指向数组的指针也是一种迭代器，可通过获取**尾后指针**来遍历数组。
  - 如`int arr[10]; int *e = &arr[10]; for (int *b = arr; b != e; ++b)`。
- C++11中引入了非成员的`begin()`和`end()`函数，可用于获取数组的首、尾后指针，它们定义在`<iterator>`中。
- 指向数组的指针支持前面所述的所有迭代器运算。
  - 两个指针相减的结果类型为`ptrdiff_t`，它是定义在`<cstddef>`中的机器相关的带符号类型。
- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值，因此内置数组的下标可为负值。

### C风格字符串

- C风格字符串是从C继承而来，它们都必须以一个空字符`\0`作为结尾。
- 在`<cstring>`中定义了一些操作C风格字符串的函数：

  | 函数 | 介绍 |
  |-----|-----|
  | `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
  | `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。`p1==p2`返回`0`，`p1>p2`返回一个正值，否则返回负值 |
  | `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1` |
  | `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1` |

- 对大多数应用来说，使用标准库`string`比使用C风格字符串更安全、更高效。
- 标准库中提供了一个`c_str()`成员函数，可将`string`转换为C风格字符串。

## 多维数组

- C++中不存在多维数组，所谓的多维数组其实是数组的数组。
- 使用范围`for`遍历多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型，从而避免数组自动被转换为指针，如：

  ```cpp
  constexpr size_t rowCnt = 3, colCnt = 4;
  int ia[rowCnt][colCnt];

  int cnt = 0;
  for (const auto &row : ia) {
      for (auto &col : row) {
          col = cnt;
          ++cnt
      }
  }
  ```

- 另外可用指针遍历多维数组：

  ```cpp
  for (auto p = ia; p != ia + 3; ++p) {
      for (auto q = *p; q != *p + 4; ++q) {
          cout << *q  << " ";
      }
      cout << endl;
  }
  ```

- 还可用类型别名简化多维数组的指针：

  ```cpp
  using int_array = int[4];
  //typedef int int_array[4]; //等价声明
  for (int_array *p = begin(ia); p != end(ia); ++p) {
      for (int *q = begin(*p); q != end(*p); ++q) {
          cout << *q << " ";
      }
      cout << endl;
  }
  ```





