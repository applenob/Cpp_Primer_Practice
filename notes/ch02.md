# 第二章 变量和基本类型

## 基本内置类型

### 算数类型

- C++中内置的基本算数类型如下表：

  | 类型 | 含义 | 最小尺寸|
  |---|---|---|
  | `bool` | 布尔类型  | 8bits |
  | `char`| 字符 | 8bits |
  | `wchar_t` | 宽字符 | 16bits |
  | `char16_t` | Unicode字符 | 16bits |
  | `char32_t` | Unicode字符 | 32bits |
  | `short` | 短整型 | 16bits |
  | `int` | 整型 | 16bits (在32位机器中是32bits) |
  | `long` | 长整型 | 32bits |
  | `long long` | 长整型 | 64bits （是在C++11中新定义的） |
  | `float` | 单精度浮点数 | 6位有效数字 |
  | `double` | 双精度浮点数 | 10位有效数字 |
  | `long double` | 扩展精度浮点数 | 10位有效数字 |

  - 字符型虽被分成了`char`、`signed char`、`unsigned char`三种，但其表现形式只有后面两种。
    - `char`的具体表现形式**由编译器决定**。

### 类型转换

- 非布尔型赋给布尔型，初始值为`0`则结果为`false`，否则为`true`。
- 布尔型赋给非布尔型，初始值为`false`结果为`0`，初始值为true结果为`1`。
- 无符号的值和有符号的值进行运算时，有符号的将被转换为无符号的值。
  - 如`for (unsigned u = 10; u >= 0; --u)`中`u`始终不为`0`，将造成死循环。

### 字面值常量

- 形如`42`这样，一望可知的的值被称作**字面值常量**（literal），其形式和值决定了其具体的数据类型。
- 对于整型和浮点型字面值：
  - 十进制字面值：容纳其数值的类型为`int`、`long`、`long long`中尺寸最小的。
  - 八/十六进制字面值：容纳其数值的类型为`(unsigned) int`、`(unsigned) long`、`(unsigned) long long`中尺寸最小的。
  - 浮点型字面值：一般用小数或科学计数法表示（指数用`E`或`e`标识），容纳其数值的默认类型为`double`。
  - 可通过添加后缀`u/U`（unsigned）、`l/L`（long）、`ll/LL`（long long）、`f/F`（float）来明确指定字面值类型，如`42ULL`。
- 对于字符和字符串字面值：
  - 字符字面值：由单引号括起来，默认为`char`型，如`'a'`。
  - 字符串字面值：由双引号括起来，实际为常量字符构成的数组，编译器将自动为其末尾添加空字符`\0`，如`"Hello World"`。
  - 可通过添加前缀`u`（char_16）、`U`（char_32）、`L`（wchar_t）、`u8`（char）来明确指定字面值类型，如`L'a'`。
- 换行符`\n`、制表符`\t`等以反斜线`\`开始的C++规定的转义序列（escape sequence）一般被当作一个字符使用。
  - 此外还有泛化的转义序列，形式为`\x`后接不定个十六进制数或`\`后接最多3个八进制数。
- `true`和`false`是布尔字面值，另外还有`nullptr`则是指针字面值。

## 变量

- **变量**提供一个具名的、可供程序操作的存储空间。
- C++中**变量**和**对象**一般可以互换使用。

### 变量定义

- 定义形式：类型说明符加一个或多个变量名组成的列表，如`int sum = 0, value, units_sold = 0;`。
- **初始化**（initialize）是在对象在创建时立即获得一个特定的值。
  - 注意**初始化不是赋值**，前者创建变量的同时赋予初始值，后者擦除对象的当前值然后用新值代替。
- C++11中新增了**列表初始化**（list initialization），可使用花括号`{}`来初始化对象或对其赋值。
  - 如`int units_sold{0}; int units_sold = {0};`。
  - 对内置类型的变量使用列表初始化，**初始值存在丢失信息风险时（发生隐式类型转换）将报错**。
- 对于函数体外的全局变量，定义时没有指定初始值将被默认初始化，内置类型一般会被默认初始化为为`0`。
  - 在函数体内部的内置类型变量将不会被初始化，其值未定义。
- 建议初始化每一个内置类型的变量。

### 声明和定义的关系

- 为了支持分离式编译，C++将声明和定义区分开：
  - **声明**（declaration）使得名字为程序所知；
  - **定义**（definition）负责创建与名字关联的实体。
- 通过添加`extern`关键字，可只声明而不定义变量，如`extern int i;`，`int j;`则是声明并定义了`j`。
  - 如果其中包含了显式初始化的声明，则`extern`的作用被抵消，声明变成了定义，如`extern double pi = 3.14;`。
- 变量只能被定义一次，但是可以多次声明。

### 标识符

- 由字母、数字、下画线组成。
- 保留字外的自定义标识符：
  - 大小写敏感；
  - 以字母或下画线开头；
  - 不能连续出现两个下画线；
  - 不能以下画线紧连大写字母开头；
  - 函数体外的标识符不能以下划线开头。

### 作用域

- 作用域（scope）是程序的一部分，同一名字在不同的作用域中将指向不同的实体。
  - 全局作用域（global scope）：整个程序范围内都可使用。
  - 块作用域（block scope）：只限在块内使用。
  - C++中大部分作用域都以花括号进行分隔。
- 作用域可彼此包含，从而形成内层及外层作用域。
- 在块作用域中，可通过作用域运算符`::`显式地访问全局变量，如`std::cout << ::reused;`。

## 复合类型

### 左值和右值

- **左值**（l-value）：可以出现在赋值语句的左边或者右边，如变量。
- **右值**（r-value）：只能出现在赋值语句的右边，如字面值常量。

### 引用

- 引用一般指的是**左值引用**（lvalue reference），且C++11中新增了**右值引用**（rvalue reference）。
- 引用是为对象起了一个别名，引用类型引用（refer to）了另外一种类型，如`int ival = 1024; int &refVil = ival;`。
- 引用必须初始化，且初始值必须为一个对象, 它与其初始值**绑定**后就无法再绑定其他对象。
  - 引用只是已存在对象的一个别名，本身并非对象，因此不可定义引用的引用。

### 指针

- 指针是一种**指向（point to）**另外一种类型的复合类型，其存放了其所指对象的地址。
  - 它也实现了对对象的间接访问，与引用不同，指针本身就是一个对象，定义时可以不赋初值。
- 一般在类型名之后、变量名之前加类型修饰符`*`来定义指针，为指针赋值则要用到取地址符`&`。
  - 例如`int ival = 42; int *p; p = &ival;`。
- 指针指向了某个对象时，可用解引用符`*`来访问该对象，如`*p = 0;`，将把`ival`重新赋值为`0`。
  - 给指针赋值是令其存放一个新的地址，从而指向一个新对象。
- 指针或指向一个对象，或指向紧邻对象的下一个位置，或为空指针，否则为无效指针。
  - 空指针不指向任何对象，C++11中可用`nullptr`来得到空指针，等价于直接将指针赋值为字面值常量`0`。
  - 指针用于条件表达式时，非`0`（即`nullptr`）的指针对应的条件值都为`true`。
- `void*`指针类型可用来存放任意对象的地址，其他指针类型必须要与所指对象严格匹配。
- 可定义指向指针的指针，且可通过`*`的个数区分指针的级别，还可定义对指针的引用，但不存在指向引用的指针。
  - **从右向左读**有助于弄清楚复合声明语句的确切含义。
  - 如多重指针：`int ival = 1024; int *pi = &ival; int **ppi = &pi;`；
  - 对指针的引用：`int i = 42; int *p; int *&r = p; r = &i; *r = 0;`。

## const限定符

- `const`对象必须初始化，且定义后其值就不能再改变。
- `const`变量默认不能被其他文件访问，要实现多文件间共享，必须在在声明和定义变量时都加上`extern`。

### const的引用

- **对常量的引用**（reference to const）是指向`const`对象的引用，引用及其引用对象都为常量。
  - 如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
- 允许用任意结果**可被够转换成引用类型**的表达式来初始化常量引用，如`const int &r1 = 42; const int &r2 = r1 * 2;`。
- **临时量**（temporary）对象是当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
  - 对临时量的引用是非法行为，因此引用必须绑定与其相同的类型，如`int &r3 = r1 * 2;`就是非法的。
- 常量引用仅对**引用可参与的操作**进行了限定，而对引用对象本身不构成影响。

### 指针和const

- **指向常量的指针**（pointer to const）不能用来改变其所指对象的值。
  - 如 `const double pi = 3.14; const double *cptr = &pi;`。
  - 允许指向常量的指针指向非常量对象，如`double dval = 3.14; cptr = &dval;`。
- **常量指针**（const pointer）是指针本身是常量的指针，其必须进行初始化，如`int i = 0; int *const ptr = &i;`。
- 同样的，指向常量的指针仅对**指针可参与的操作**进行了限定，而对指针所指对象本身不构成影响。

### 顶层const

- **顶层const**：指针本身是个常量，更一般地表示任意对象为常量。
  - 如`int i = 0; int *const p1 = &i; const int ci = 42;`，`p1`和`ci`都是顶层`const`对象。
- **底层const**：指针指向的对象是个常量，与指针、引用等复合类型的基本类型相关。
  - 如`const int *p2 = &ci, const int &i = ci;`。
- 拷贝时操作不改变被拷贝对象的值，不受顶层`const`的影响，但严格要求相同的底层`const`资格或可进行数据转换。

### constexpr和常量表达式

- **常量表达式**（const expression）指的是值不会改变且在编译过程中就能得到计算结果的表达式。
- `C++11`中允许将变量声明为`constexpr`类型，以便**由编译器来验证**变量的值是否是一个常量的表达式。
  - 声明为`constexpr`时所用到的类型需要为**字面值类型**，如算数类型、引用、指针等。
  - `constexpr`指针的初始值必须为`0`、`nullptr`或固定地址中的对象（定义在函数体之外）。
  - 定义为`constexpr`的对象为顶层`const`，如`constexpr int *q = nullptr`，`q`为指向整数的常量指针。

## 处理类型

### 类型别名

- C++11之前，一般都使用`typedef`来定义类型的同义词，如`typedef double wages;`。
- C++11中可用`using`别名声明来定义类型别名，如`using SI = Sales_item;`。
- 使用类型别名指代复合类型或常量时，需要注意别名的实际含义。
  - 如`typedef char *pstring; const pstring cstr = 0`：
    - `pstring`实际为`char *`的别名，则`const pstring`的实际含义为`char *const`，而非`const char*`。

### auto类型说明符

- C++11中引入了`auto`来实现让编译器自动进行类型推断，如`int i = 0, &r = i; auto a = r;`，将推断`a`的类型为`int`。
  - 用`auto`在一条语句中声明多个变量时，所有变量的初始基本类型必须一致。
- `auto`一般会忽略顶层`const`。
  - 如`const int ci = 1; auto e = &ci; const auto &j = 42;`：
    - `e`的推断类型为`const int *`；
    - `j`的推断类型为`int`，且必须用`const`声明为常量才能作为常量引用，绑定字面值。
- 设置类型为`auto`的引用时，初始值的顶层`const`属性依旧保留。
  - 如`auto &g = ci`，`g`的推断类型为`const int&`。

### decltype类型指示符

- C++11中还引入了`decltype`，它可从表达式的类型推断出要定义的变量的类型，选择并返回操作数的数据类型。
  - 如`decltype(f()) sum = x;`，推断出的函数`f`的返回类型将作为`sum`的类型。
- `decltype`不会忽略顶层`const`和引用。
  - 如`int i = 42, *p = &i, &r = i;`：
    - `decltype(r) a = i;`的类型为`int&`；
      - 引用一直都只是所指对象的同义词，只有用`decltype`处是个例外。
    - `decltype(r + 0) b;`的类型则为`int`；
      - 表达式`r + 0`的结果为`int`。
    - `decltype(*p) c = i;`的类型也为`int&`；
      - 因为解引用指针不仅可得到指针所指对象，同时还能给该对象赋值。
    - `decltype(&p) d = &p;`的类型则为`int **`。
- `decltype`的结果类型与表达式形式密切相关，表达式如果是个变量名，加括号和不加括号将影响推断结果。
  - 加括号的变量被当成表达式，而变量是一种可作为赋值语句左值的特殊表达式。
  - 表达式的求值结果为左值时，将推断为引用类型。
  - 如`int i = 42; decltype((i)) d = i; decltype(i) e;`，`d`的类型会是`int&`。

## 自定义数据结构

### 定义类型

- 定义类时一般以关键字`struct`开始，后面紧跟类名和类体，例如：
  ```cpp
  struct Sales_data {
      std::string bookNo;
      unsigned units_sold = 0;
      double revenue = 0.0;
  }
  ```
  - 该类中只有**数据成员**（data member），这些成员在各个类中相互独立。
  - C++11中，可以为类数据成员提供一个类内初始值，创建对象时将用类内初始值初始化数据成员，否则成员将被默认初始化。

### 编写头文件

- 为保证各文件中的类的定义一致，通常把类定义在后缀名为`.h`的头文件中。
- 头文件通常包含哪些只能被定义一次的实体，如类、`const`和`constexpr`变量。
- **预处理器**（preprocessor）是在程序编译之前执行的一段程序，可用来确保头文件被多次包含的情况下程序仍能安全工作。
  - `#include`即为一项预处理功能，当预处理器看到它时，会用指定的头文件内容代替`#include`。
- **头文件保护符**（header guard）也是一项常用的预处理功能，它通过设置一个预处理变量来防止文件被重复包含。
  - 一般以全大写、用下划线`_`分隔的头文件名作为预处理变量名。
  - 先用`#ifndef`确定预处理变量是否已定义，接着用`#define`指令定义该变量，最后以`#endif`结束定义，如：  
  ```cpp
  #ifndef SALES_DATA_H
  #define SALES_DATA_H
  strct Sale_data{
      ...
  }
  #endif
  ```
