# 第四章 表达式

## 基础

- **重载运算符**（overloaded）：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- C++的表达式要么为**左值**（lvalue）要么为**右值**（rvalue），当一个对象：
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）；
  - 被用作**右值**的时候，用的是对象的**值**（内容）。
- 不同的运算符对运算对象的要求各不相同，需要右值的地方可用左值代替，当不可将右值当作左值使用。
- 运算符的优先级与结合律决定了运算对象的组合方式，但没有说明运算对象的**求值顺序**。
  - 如`int i = fn1() * fn2();`中，`fn1()`、`fn2()`的调用顺序不定。
- 只有`&&`、`||`、`?:`、`,`这四个运算符规定了求值顺序，其他运算符中求值顺序不定，要避免出现未定义行为。
  - 如`int i = 0; cout << i << " " << ++i << endl;`中，`i`和`i++`的求值顺序不定。
  - 以下循环的行为也是未定义的：
    ```cpp
    while (beg != s.end() && !isspace(*beg)) {
        *beg = toupper(*beg++);
    }
    ```

## 算术运算符

- 当计算的结果超出其类型所能表示的范围时，将会发生**溢出**。
- C++11中规定，除法运算中求得的商一律向`0`取整，且`m%(-n)`等于`m%n`，`(-m)%n`等于`-(m%n)`。

## 逻辑运算符

- 逻辑与运算符`&&`和逻辑或运算符`||`都采用**短路求值**（short-circuit evalution）策略：
  - 先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。

## 赋值运算符

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 和其他二元运算符不一样，赋值运算符满足右结合律。
  - 如`ival = jval = 0;`等价于`ival = (jval = 0);`。

## 成员访问运算符

- 点运算符`.`和箭头`->`运算符都可用于成员访问，且`ptr->mem`等价于`(*ptr).mem`。

## 条件运算符

- 条件运算符（`?:`）可把`if-else`逻辑嵌入到单个表达式中，形式为：`cond? expr1: expr2`。
- 条件运算符的优先级较低，通常需要给它加括号。

## 位运算符

- 位运算符把运算对象看作二进制位的集合，作用于整数类型。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位将被舍弃。

## sizeof运算符

- `sizeof`运算符返回一条表达式或一个类型名字所占的字节数，类型为`size_t`。
  - 其运算对象有两种形式：
    - `sizeof (type)`：返回类型的大小，如`sizeof(Sales_data);`；
    - `sizeof expr`：返回表达式结果类型的大小。如`sizeof data;`。
- 对解引用指针执行`sizeof`运算，得到指针所指对象所占空间大小，且指针不需要是有效的，如`sizeof *p;`。
- C++11中允许使用作用域运算符，来得到类成员的大小，如`sizeof Sales_data::revenue;`。
- 对数组执行`sizeof`运算，得到整个数组所占空间大小，而不会把数组当指针处理。
- 对`vector`、`string`等容器类执行`sizeof`运算，只返回该类型固定部分大小，而不会计算容器中的元素所占用的空间。

## 类型转换

### 隐式类型转换

- 以下情况会自动发生隐式类型转换：
  - 比`int`类型小的整数值先提升为较大的整数类型。
  - 条件中，非布尔转换成布尔。
  - 初始化中，初始值转换成变量的类型。
  - 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
  - 函数调用时。
  - 大部分用到数组的表达式中，数组自动转换为指向数组首元素的指针。
- 无符号类型和带符号类型进行运算，无符号类型**不小于**带符号类型时，带符号类型将被转会为无符号类型。
- 带符号类型大于无符号类型，转换结果依赖于机器。无符号类型的表示范围在带符号类型之内则被转换为带符号类型。

### 命名的强制类型转换

- 一个命名的强制类型转换形式为：`cast-name<type>(expression)`，其中`cast-name`有：
  - `static_cast`：对不包含底层`const`的运算对象都有效。
    - 如`void *p = &d; double *dp = static_cast<double*>(p);`。
  - `const_cast`：只能改变运算对象的底层`const`，可用于去除`const`属性，常用于有函数重载的上下文中。
    - 如`const char *pc; char *p = const_cast<char*>(pc);`。
  - `reinterpret_cast`：为运算对象的位模式提供低层次上的重新解释，本质上依赖于机器。
    - 如`int *ip; char *pc = reinterpret_cast<char*>(ip);`。
  - `dynamic_cast`：支持运行时类型识别。

## 运算符优先级表

| 运算符 | 结合律 | 功能 | 优先级 |
|-------|-------|------|-------|
| `::` | 左 | 作用域 | 1 |
| `.`/`->`| 左 | 成员选择 | 2 |
| `[]`/`()` | 左 | 下表/函数调用、类型构造 | 2 |
| `++`/`--` | 右 | 后置递增/减 | 3 |
| `typeid` | 右 | 类型ID | 3 |
| `cast_name<type>` | 右 | 显示类型转换 | 3 |
| `++`/`--` | 右 | 前置置递增/减 | 4 |
| `~`/`!` | 右 | 位求反/逻辑非 | 4 |
| `+`/`-` | 右 |  一元正/负号 | 4 |
| `*`/`&` | 右 | 解引用/取地址 | 4 | 
| `()` | 右 | 强制类型转换 | 4 |
| `sizeof`/`sizeof...` | 右 | 类型/参数包大小 | 4 |
| `new`/`new[]` | 右 | 创建对象/数组 | 4 |
| `delete`/`delete[]` | 右 | 释放对象/数组 | 4 |
| `noexpect` | 右 | 能否抛出异常 | 4 |
| `.*`/`->*` | 左 | 指向成员选择的指针 | 5 |
| `*`/`/`/`%` | 左 | 乘/取余/取模 | 6 |
| `+`/`-` | 左 | 加/减 | 7 |
| `<<`/`>>` | 左 | 左/右移位 | 8 |
| `<`/`<=`/`>`/`>=` | 左 | 大小比较 | 9 |
| `==`/`!=` | 左 | 相等性比较 | 10 |
| `&` | 左 | 位与 | 11 |
| `\|` | 左 | 位或 | 12 |
| `^` | 左 | 位异或 | 13 |
| `&&` | 左 | 逻辑与 | 14 |
| `\|\|` | 左 | 逻辑或 | 15 |
| `?:` | 右 | 条件 | 16 |
| `=` | 右 | 赋值 | 17 |
| `*=`/`+=`/`<<=`/`&=` | 右 | 复合赋值 | 17 |
| `throw` | 右 | 抛出异常 | 18 |
| `,` | 左 | 逗号 | 19 |