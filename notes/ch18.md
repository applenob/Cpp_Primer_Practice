# 第十八章 用于大型程序的工具

- 大规模应用程序的特殊要求包括：
  - 在独立开发的子系统之间协同处理错误的能力（异常处理）；
  - 使用各种库进行协同开发的能力（命名空间）；
  - 对比较复杂的应用概念建模的能力（多重继承）。

## 异常处理

- **异常处理**（exception handling）机制允许程序中独立开发的部分能够在**运行时**就出现的问题进行通信并作出相应的处理。

### 抛出异常

- C++中通过**抛出**（throwing）一条表达式来**引发**（raised）一个异常。
- 异常的类型和当前的调用链决定了哪段**处理代码**（handler）将用来处理该异常。
- 异常处理是一个**栈展开**（stack unwinding）的过程：
  - 当`throw`出现在一个`try`语句块时，检查该`try`语句块相关的`catch`字句：
    - 若有匹配，则处理；
    - 若无匹配，则继续检查外层的`try`匹配的`catch`，仍无匹配时将调用`terminate`终止程序。
- 栈展开的过程中将自动执行各类局部对象的析构函数，因此析构函数不应该抛出不可被自身处理的异常。
- **异常对象**（exception object）需要通过异常抛出表达式进行拷贝初始化，因此`throw`语句中的表达式必须拥有**完全类型**。
  - 表达式为类类型时，必须具有可访问的析构函数、拷贝或移动构造函数；
  - 表达式为数组或函数类时，将被转换为对应的指针类型。
- 抛出一条表达式时，表达式不可为局部对象，且其**静态编译时类型**决定了异常对象的类型。

### 捕获异常

- `catch`子句中需进行**异常声明**（exception declaraion），格式类似包含一个形参的函数形参列表。
  - `catch`无需访问抛出的表达式时可忽略捕获形参的名字。
- 异常声明的类型决定了可捕获的异常类型，其必须为完全类型，可为左值引用，但不可为右值。
  - 类型为非引用类型时，将对异常对象进行拷贝。
  - 基类类型可使用派生类异常对象对其初始化，且为引用类型时将进行动态绑定。
  - 异常声明的静态类型决定了`catch`语句可执行的操作。
- 对抛出的异常查找对应的`catch`语句时，得到的会是第一个与异常匹配而非最佳匹配的语句，因此越专门的`catch`语句应该放到越前面。
  - 派生类异常的处理代码应出现在基类之前。
  - 匹配时只允许非常量到常量、派生类到基类、数组/函数到指针的类型转换。
- 单独的`catch`语句不能完整处理某个异常时，可通过**重新抛出**（rethrowing）将异常传递给另一个`catch`语句。
  - 格式为一条空的`throw`语句：`throw;`。
  - 空的`throw`语句只能出现在`catch`或`catch`直接或间接调用的函数内，否则编译器在遇到它时将调用`terminate`。
- 异常声明为省略号`...`时，表达式该`catch`语句可捕获所有异常。
  - 与其他`catch`语句一起出现时，`catch(...)`必须放在最后。

### 函数try语句块

- 要处理构造函数初始值抛出的异常，唯一方法是将构造函数写成函数`try`语句块（funcion try block）。
  - 此时的`catch`语句既能处理构造（析构）函数体，也能处理构造（析构）函数的初始化（析构）过程。
- 例如把`Blob`构造函数放入一个函数`try`语句块：
    ```cpp
    template <typename T>
    Blob<T>::Blob(std::initializer_list<T> il) try: 
        data(std::make_shared<std::vector<T> >(il){
            /*空函数体*/
        } catch(const std::bad_alloc &e) { 
            handle_out_of_memory(e); 
        }
    ```

### noexcept异常说明

- C++11中，可使用`noexcept`说明指定某个函数不会抛出异常。
  - `noexpect`需要同时出现在声明和定义语句中；
  - `noexpect`紧跟在函数的参数列表、`const`/引用限定符之后，函数的尾置返回类型、`final`、`override`、`=0`之前。
- 做了不抛出说明后仍可抛出异常，编译器不会在编译时检查`noexpect`说明，在时程序将调用`terminate`以完成运行时不抛出异常的承诺。
  - 在确认函数不抛出异常或不知道如何处理异常时，可用`noexcept`进行说明。
- 旧的C++标准使用`throw`跟上括号括起来的异常类型说明函数可能抛出的异常类型，C++11中`throw()`的效果等同`noexpect`。
  - 如声明`void recoup(int) noexcept;`和`void recoup(int) throw();`是等价的。
- `noexpect`说明符接受一个`bool`类型的可选参数，实参为`true`时表示不抛出异常。
- `noexpect`说明符的实参常与一元运算符`noexcept`混合使用，它返回`bool`类型右值常量表达式，表示给定的表达式是否会抛出异常。
  - 如`void f() noexcept(noexcept(g()));`，`f`和`g`的异常说明一致。
- 异常说明对指针、虚函数、拷贝控制都会产生影响：
  - 函数指针与该指针指向的函数必须具有一致的异常说明；
    - 如`void （*pf1)(int) noexcept = recoup;`，`pf1`只能指向不抛出异常的函数。
  - 承诺了不抛出异常的虚函数，后续派生出来的虚函必须做同样的承诺；
  - 成员和基类的所有操作都承诺不抛出异常时，编译器合成的拷贝控制成员也会是`noexcept`的。

### 异常类层次

- 标准库的`exception`构成如下的继承体系：
  - `exception`
    - `bad_cast`
    - `bad_alloc`
    - `runtime_error`
      - `overflow_error`
      - `underflow_error`
      - `range_error`
    - `logic_error`
      - `domain_error`
      - `invalid_argument`
      - `out_of_range`
      - `length_error`
  - 异常类是按照层次关系组织的，层次越低情况越特殊。
  - 第二层划分了运行时和逻辑两大错误类，前者在运行时才能检测到，后者则可在程序代码中发现。
- `exception`类仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和名为`what`的虚成员。
  - `what`返回`const char*`，是一个以`\0`结尾的字符串数组，且不抛出异常。
- 实际中一般会通过定义`exception`的派生类，来得到应用相关的异常类。
  - 例如下面为书店应用程序设定的异常类：
    ```cpp
    class out_of_stock: public std::runtime_error {
        explicit out_of_stock(const std::string &s):
        std::runtime_error(s){ }
    };
    ```

## 命名空间

- 多个库将名字放置在全局命名空间中容易引发**命名空间污染**（namespace pollution）。
- **命名空间**（namespace）可以将全局命名空间分割为多个作用域。

### 命名空间定义

- 命名空间的定义由关键字`namespace`和命名空间组成，后面紧跟由花括号括起来的各种声明和定义。
  - 命名空间的名字必须在其作用域内保持唯一。
  - 类、变量、函数、模板及其他命名空间等可以出现在全局作用域的声明都能置于命名空间中。
  - 命名空间可定义在全局作用域或其他命名空间中，但不可定义于函数或类的内部。
  - 例如：

  ```cpp
  namespace cplusplus_primer{
      class Sales_data { ... };
      Sales_data operator+(const Sales_data&, const Sales_data&);
      ...
  }
  ```
- 每个命名空间都是一个**作用域**，其中的每个名字必须为作用域内的唯一实体。
- 同一个命名空间内的名字相互之间可以直接访问，空间之外则需要通过空间名加作用域运算符`::`进行访问。
- 不同于其他作用域，命名空间可以是**不连续**的，同一命名空间可以在不同的文件中多处出现。
  - 因此定义某个命名空间时，或是新建了一个命名空间，或是重新打开已有的命名空间并向其中添加新成员。
- **全局命名空间**（global namespace）是隐式的，没有名字，但可用`::member_name`的形式访问全局命名空间的某个成员。
- 命名空间可以嵌套，且内层空间中声明的名字将隐藏外层中的同名成员。
- C++11支持定义**内联命名空间**（inline namespace），即外层命名空间可以直接访问内联命名空间的名字。
  - 定义方式是在`namespace`前加`inline`，例如：
  ```cpp
  namespace cplusplus_primer{
      inline namespace FifthEd{
          class Query_base {};
      }
  }
  ```
  - 之后通过外层的命名空间名就可以访问`Query_base`：`cplusplus_primer::Query_base qb;`。
- 此外还支持**未命名的命名空间**（unnamed namespace），其中定义的变量拥有静态生命周期。
  - 它们在第一次使用前创建，到程序结束则被销毁，因此不能跨越多个文件。
  - C++中用它来代替C中的`static`全局变量的定义方式。

### 使用命名空间成员

- 可以声明**命名空间的别名**，方式如`namespace primer = cplusplus_primer;`。
- **using声明**（using declaration）可用来引入命名空间的某个成员，且一条`using`声明一次只引入命名空间的一个成员。
  - 引入后其有效范围一直到`using`声明所在的作用域结束。
  - 可出现在全局、局部、命名空间及类的作用域中，它将隐蔽外层作用域中的同名实体。
  - 如`using std::cin`。
- **using指示**（using directive）则可以引入整个命名空间，形式是`using namespace`再加命名空间名。
  - 引入后其有效范围一直到`using`指示所在的作用域结束。
  - 可出现在全局、局部及命名空间作用域中，不可出现在类的作用域中。
  - 如`using namespace std;`。
- 尽可能使用**using声明**而避免使用**using指示**。

### 类、命名空间与作用域

- 命名空间内部名字的查找规则也是由内向外依次查找各外层作用域，只有在使用点前声明且位于开方块的名字才被考虑。
- 当给函数传递类类型对象（包括引用、指针）时，除了常规的作用域之外，还会在实参类所属的命名空间中进行查找。
  - 从而允许作为类接口一部分的非成员函数不需要使用单独的`using`声明即可调用。
  - 因此，执行`std::sting s; std::cin >> s;`时，将从`std`命名空间内中匹配到对应的调用`std::oprator>>(std::cin, s);`。
  - 这也会对类声明过的友元的查找产生影响，例如：
  ```cpp
  namespace A {
      class C {
          friend void f1(); // 没有其他声明时，它们隐式地成为命名空间A中的成员
          friend void f2(const C&);
      };
  }
  int main() {
      A::C cobj;
      f1(cobj); // 通过A::C对象cobj可以查找到f1
      A::f2(); // 必须加上命名空间才能访问
  }
  ```

### 重载与命名空间

- 对于接受类类型实参的函数，将在实参类（包括其基类）所属的命名空间中搜寻候候选函数。
- `using`声明将把函数的所有版本都引入到当前作用域中，当引入的函数与当前作用域已有的函数完全相同时将引发错误。
- `using`指示将命名空间中的成员提升到外层作用域中，且引入的函数与当前作用域已有的函数完全相同时不会发生错误，此时只需要显式指明调用的版本所在的命名空间。

## 多重继承与虚继承

- **多重继承**（multiple inheritance）：从多个直接基类产生派生类的能力。

### 多重继承

- 派生类的派生列表中可包含多个类，且每个类前面包含一个可选的访问说明符。
  - 如`class Bear : public ZooAnimal { }; class Panda : public Bear, public Endangered { };`
- 多重继承而来的派生类对象中包含有每个基类的子对象。
- 派生类构造函数将初始化其所有基类，且基类的构造顺序与派生类列表中基类的出现顺序一致。
  - 例如前面的`ZooAnimal`将被首先初始化，随后是`Bear`、`Endangered`，最后才是`Panda`。
- C++11允许派生类从其多个基类中继承构造函数，但从多个基类继承了相同的构造函数时，就必须定义自己的版本。
  - 如下面的派生类：
  ```cpp
  struct Base1 {
      Base1() = default;
      Base1(const string&);
      Base1(shared_ptr<int>);
  };
  struct Base2 {
      Base2() = default;
      Base2(const string&);
      Base2(int);
  }
  struct D1 : public Base1, public Base2 {
      using Base1::Base1;
      using Base2::Base2;
      D2(const string&s) : Base1(s), Base2(s) { }
      D2() = default;
  }
  ```
- 多重继承下的拷贝、移动及析构过程，都与单继承下的行为一致。

### 类型转换与多个基类

- 和单继承一样，多重继承下可以令某个可访问基类的指针或引用直接指向一个派生类对象。
- 派生类向多个基类间的转换都是一样好的，因此将派生类对象作为实参传递给接受基类的重载函数时，可能发生二义性错误。
- 和单继承一样，对象、指针和引用的静态类型决定了可调用的成员。

### 多重继承下的类作用域

- 多重继承下，名字查找过程将在派生类的所有直接基类中同时进行，相同的名字可在多个基类中找到时，该名字将具有二义性。
  - 使用具有二义性的名字时，需要加前缀限定符以明确指出要使用的版本。
  - 要避免潜在的二义性，最好是直接在派生类中定义新版本。

### 虚继承

- 派生类可以多次继承同一个类，如通过两个直接基类分别继承同一个间接基类，从而会包含某个类的多个子对象。
- **虚继承**（virtual inheritance）可以令某个类做出愿意共享其基类的承诺，而将共享的基类子对象作为**虚基类**，使得派生类多次继承该虚基类时，都只会包含唯一的虚基类子对象
  - 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，而不影响派生类本身。
- 指定虚基类的方式是在派生类列表中加关键字`virtual`，它和访问说明符的出现顺序不定。
  - 如`class Bear : vitrual public ZooAnimal { };`，

### 构造函数与虚继承

- 虚基类由最底层的派生类进行初始化。
  - 如`Bear`虚继承自`ZooAnimal`后，`Panda`的构造函数将控制`ZooAnimal`的初始化过程。
- 对于含有虚基类的对象，将首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序对其进行初始化。
  - 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。
- 一个类可有多个虚基类，这些子对象**按照其在派生类列表中出现的顺序从左到右**依次构造。